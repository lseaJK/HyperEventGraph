
# HyperEventGraph V2.0: Agent驱动的智能图谱构建框架 - 需求文档

**版本**: 2.0
**作者**: Gemini Architect
**日期**: 2025-07-14

---

## 1. 核心愿景与设计原则

### 1.1 项目愿景

构建一个**自适应、自进化**的领域事件知识图谱系统。该系统不仅能从非结构化文本中深度抽取已知事件，还能通过Agent协作**自动发现、学习并掌握未知事件类型**，并**深度解析事件之间的复杂事理逻辑**，最终形成一个动态演进、持续增长的“活”知识库。

### 1.2 核心设计原则

- **Agent化 (Agent-Oriented)**: 将核心业务流程（如分诊、抽取、关系分析、学习）封装成具有明确角色、输入和输出的独立智能体(Agent)。这使得系统逻辑更清晰，更易于维护和扩展。
- **事件驱动 (Event-Driven)**: 整个工作流由数据的流入和状态变化（如“未知事件发现”）来驱动，实现高度自动化和异步协作。
- **可配置与可扩展 (Configurable & Extensible)**: 所有Agent的行为、Prompt模板、LLM模型选择、阈值等关键参数，都必须通过外部配置文件（如YAML或JSON）进行管理，严禁硬编码。
- **人机协同 (Human-in-the-Loop)**: 在关键的知识增长环节（如新Schema的最终确认）保留人工审核节点，确保系统的准确性、稳定性和可控性。

---

## 2. V2.0 核心架构：Agent协作模型

为了实现上述愿景，我们将引入一个新的核心编排器 `WorkflowController`，并定义三大核心Agent来驱动实时数据处理流程，以及一个后台Agent负责系统的长期学习。

![Agent-driven Architecture](https://i.imgur.com/your-architecture-diagram.png)  <!-- 这是一个占位符，建议后续生成架构图替换 -->

### 2.1 核心组件

- **`WorkflowController` (src/core/workflow_controller.py)**:
  - **定位**: 系统的“大脑”和总调度中心。
  - **职责**: 接收原始输入，根据预设逻辑依次调用不同的Agent，管理数据在它们之间的流转，并处理顶层异常。

- **`TriageAgent` (src/agents/triage_agent.py)**:
  - **定位**: 敏捷的“一线分诊员”。
  - **核心原则**: **速度优先，成本敏感**。
  - **职责**: 对输入文本进行快速分类，判断其描述的事件是“已知”还是“未知”，然后进行分流。

- **`ExtractionAgent` (src/agents/extraction_agent.py)**:
  - **定位**: 精准的“结构化信息抽取专家”。
  - **核心原则**: **深度与精度优先**。
  - **职责**: 针对`TriageAgent`识别出的“已知事件”，根据其精确的Schema进行深度、完整的结构化信息抽取。

- **`RelationshipAnalysisAgent` (src/agents/relationship_analysis_agent.py)**:
  - **定位**: 资深的“逻辑关系分析师”。
  - **核心原则**: **上下文感知与逻辑推理**。
  - **职责**: 分析单篇文本中多个已抽取事件之间的深层逻辑关系（因果、时序等），为事理图谱提供边。

- **`SchemaLearnerAgent` (src/agents/schema_learner_agent.py)**:
  - **定位**: 严谨的“后台知识科学家”。
  - **核心原则**: **批量处理与归纳学习**。
  - **职责**: 在后台定期或按需对“未知事件池”中的案例进行聚类、归纳，并生成新的事件Schema，提交给人类专家审核。

- **`AdminModule` (src/admin/admin_module.py)**:
  - **定位**: 系统知识的“守门员”。
  - **职责**: 提供命令行或简单的Web界面，供管理员审核、批准或拒绝由`SchemaLearnerAgent`生成的新Schema。

---

## 3. Agent化工作流详解

### 3.1 实时处理流程 (Real-time Processing Flow)

### 3.1.1 `WorkflowController` 编排逻辑详解

为了精确说明各Agent的调用时机和协作方式，以下是`WorkflowController`核心方法`.process_text(text: str)`的伪代码实现。

```pseudocode
CLASS WorkflowController:
    // 在构造函数中，通过依赖注入初始化所有需要的Agent和服务
    METHOD __init__(triage_agent, extraction_agent, relationship_agent, storage_manager, config):
        self.triage_agent = triage_agent
        self.extraction_agent = extraction_agent
        self.relationship_agent = relationship_agent
        self.storage_manager = storage_manager
        self.config = config
        LOG.info("WorkflowController 已初始化完毕，所有Agent已就位。")

    // 这是处理单个文本的核心方法
    METHOD process_text(source_text: str):
        LOG.info(f"开始处理新文本，长度: {len(source_text)}。")

        // --- 步骤1: 调用TriageAgent进行分诊 ---
        triage_result = self.triage_agent.run(text=source_text)

        // --- 步骤2: 根据分诊结果进行决策 ---
        IF triage_result.status == "unknown":
            LOG.info(f"TriageAgent判定为未知事件��建议类型: '{triage_result.proposed_type}'。流程终止。")
            // TriageAgent内部已将该未知事件存入待办池，所以这里只需终止即可
            RETURN "Process finished: Unknown event type logged."

        ELSE IF triage_result.status == "known":
            LOG.info(f"TriageAgent判定为已知事件，类型: '{triage_result.event_type}'。继续执行抽取流程。")
            
            // --- 步骤3: 调用ExtractionAgent进行深度抽取 ---
            extracted_events = self.extraction_agent.run(
                text=source_text, 
                event_type=triage_result.event_type
            )

            IF NOT extracted_events:
                LOG.warning("ExtractionAgent未能从文本中抽取到任何事件。流程终止。")
                RETURN "Process finished: No events extracted."
            
            LOG.info(f"ExtractionAgent成功抽取到 {len(extracted_events)} 个事件。")
            
            // --- 步骤4: (条件性)调用RelationshipAnalysisAgent进行关系分析 ---
            final_relations = []
            IF len(extracted_events) > 1:
                LOG.info("检测到多个事件，启动关系分析流程。")
                final_relations = self.relationship_agent.run(
                    original_text=source_text,
                    extracted_events=extracted_events
                )
                LOG.info(f"RelationshipAnalysisAgent分析完成，发现 {len(final_relations)} 个关系。")
            ELSE:
                LOG.info("仅有单个事件，跳过关系分析。")

            // --- 步骤5: 调用存储模块进行持久化 ---
            LOG.info("准备将事件和关系数据进行持久化...")
            self.storage_manager.save(
                events=extracted_events,
                relations=final_relations
            )
            LOG.info("数据已成功存入图数据库。流程处理完毕。")
            RETURN "Process finished: Events and relations saved."
            
        ELSE:
            LOG.error(f"TriageAgent返回了无法识别的状态: {triage_result.status}。流程终止。")
            RETURN "Process finished: Invalid triage status."

```
这段伪代码清晰地展示了：
- **Agent分工**: 每个Agent只负责自己的核心任务（分诊、抽取、关系分析）。
- **调用时机**:
    - `ExtractionAgent`只在`TriageAgent`返回`"known"`时被调用。
    - `RelationshipAnalysisAgent`只在`ExtractionAgent`抽取出多于一个事件时被调用。
- **数据流**: `triage_result`、`extracted_events`等数据如何在Agent之间作为输入和输出进行传递。

**Step 1: 文本输入 & 分诊**
1.  `WorkflowController` 接收到一篇原始文本。
2.  `WorkflowController` 调用 **`TriageAgent`**。
3.  `TriageAgent` 执行以下操作：
    - **输入**: 原始文本, 已知Schema列表（包含`event_type`和`description`）。
    - **逻辑**: 使用一个轻量级、快速的LLM（如 Gemini 1.5 Flash），通过一个“限定选择”的Prompt，快速判断文本属于哪个已知事件类型。如果均不匹配，则判定为“未知”。
    - **输出**:
        - **若已知**: 返回 `{"status": "known", "event_type": "...", "source_text": "..."}` 给`WorkflowController`。
        - **若未知**: 将 `{"proposed_type": "LLM建议的新类型", "source_text": "...", "status": "pending", ...}` 追加写入到 `data/pending_new_types.jsonl` 中，并向`WorkflowController`返回一个终止信号。**当前文本的处理流程结束**。

**Step 2: 深度信息抽取**
1.  `WorkflowController` 收到`TriageAgent`的“已知”信号。
2.  `WorkflowController` 调用 **`ExtractionAgent`**。
3.  `ExtractionAgent` 执行以下操作 (此Agent是对现有`src/event_extraction`模块的重构和封装):
    - **输入**: 原始文本, 一个明确的 `event_type`。
    - **逻辑**: 从`config/event_schemas.json`中加载指定`event_type`的完整Schema和对应的Prompt模板，调用一个能力更强的LLM（如 DeepSeek V3, Gemini 1.5 Pro）进行精细、结构化的信息抽取。
    - **输出**: 结构化的事件对象列表 `List[Event]`。

**Step 3: 事理关系分析**
1.  `WorkflowController` 检查`ExtractionAgent`的输出。如果事件数量小于2，则跳过此步骤。
2.  `WorkflowController` 调用 **`RelationshipAnalysisAgent`**。
3.  `RelationshipAnalysisAgent` 执行以下操作 (此Agent是对现有`src/event_logic`模块的重构和封装):
    - **输入**: 原始文本, 事件列表 `List[Event]`。
    - **逻辑**:
        1.  **[可选]** 调用`GraphRAGEnhancer`为事件上下文进行知识增强。
        2.  构建包含上下文、事件对的Prompt，调用LLM分析它们之间的因果、时序、条件、层级关系。
        3.  **[可选]** 调用`GraphRAGEnhancer`对LLM生成的关系进行二次验证和置信度打分。
    - **输出**: 结构化的关系列表 `List[Relation]`。

**Step 4: 图谱构建与持久化**
1.  `WorkflowController` 将最终的事件列表和关系列表打包。
2.  数据被发送给 `src/core/dual_layer_architecture` 模块。
3.  `dual_layer_architecture` 与 `src/storage` 模块协作，将事件和关系分别持久化到Neo4j和ChromaDB中。

### 3.2 后台学习流程 (Background Learning Flow)

这是一个异步的、由`SchemaLearnerAgent`驱动的流程，旨在实现系统的自我进化。

1.  **触发**: `SchemaLearnerAgent`可以被定时任务（如每天凌晨）或管理员手动触发。
2.  **聚类**: Agent扫描`data/pending_new_types.jsonl`中所有`status: "pending"`的记录，通过文本嵌入（Embedding）和聚类算法（如DBSCAN）将相似的未知事件归为一类。
3.  **提议**: Agent向管理员呈现聚类结果，并建议合并为一个统一的新事件类型（例如，将“产品发布”、“新品上市”合并为“产品发布”）。
4.  **归纳生成**: 管理员确认后，Agent将该聚类下的所有原始文本作为上下文，通过一个精心设计的“元学习”Prompt，让强大的LLM归纳并生成一个符合系统规范的JSON Schema。
5.  **暂存待审**: 生成的Schema被保存到 `data/proposed_schemas/{new_event_type}.json`。
6.  **人工审核**: 管理员使用`AdminModule`审查这个新Schema。
    - **批准**: Schema被合并到主知识库`config/event_schemas.json`中，同时更新`.jsonl`文件中相关记录的状态为`learned`。**至此，系统完成了一次知识迭代。**
    - **拒绝**: 更新`.jsonl`文件中相关记录的状态为`rejected`，防止重复学习。

---

## 4. 项目重构计划 (Refactoring Plan)

为了从当前架构平滑过渡到V2.0的Agent化架构，建议遵循以下分阶段实施计划：

- **第一阶段：控制器与Agent骨架搭建 (1周)**
    1.  创建 `src/core/workflow_controller.py`，定义核心处理流程的框架。
    2.  创建 `src/agents/` 目录。
    3.  在 `src/agents/` 下创建 `triage_agent.py`, `extraction_agent.py`, `relationship_analysis_agent.py`, `schema_learner_agent.py` 四个文件，并定义好每个Agent的基类、`__init__`方法和核心执行方法（如`.run()`或`.execute()`)的接口。
    4.  创建 `src/admin/admin_module.py` 的文件和基本框架。

- **第二阶段：核心逻辑迁移与封装 (2周)**
    1.  **重构`ExtractionAgent`**: 将 `src/event_extraction` 模块中的核心抽取逻辑（Prompt加载、LLM调用、JSON解析）完整地迁移并封装到`ExtractionAgent`的执行方法中。
    2.  **重构`RelationshipAnalysisAgent`**: 将 `src/event_logic` 模块中的关系分析逻辑（上下文增强、关系推理、验证）完整地迁移并封装到`RelationshipAnalysisAgent`的执行方法中。
    3.  **实现`TriageAgent`**: 实现`TriageAgent`的轻量级分类逻辑，包括其专用的Prompt。

- **第三阶段：工作流串联与测试 (1周)**
    1.  在 `WorkflowController` 中实现调用三大Agent（Triage, Extraction, Relationship）的完整数据流转逻辑。
    2.  修改项目入口脚本（如 `run_real_data_pipeline.py`），使其不再直接调用旧模块，而是通过实例化并运行 `WorkflowController` 来启动整个流程。
    3.  编写集成测试，确保新���Agent化工作流能够正确处理已知事件，并能正确识别和归档未知事件。

- **第四阶段：后台学习系统实现 (1.5周)**
    1.  **实现`SchemaLearnerAgent`**: 实现文本嵌入、聚类、Schema归纳生成的核心逻辑。
    2.  **实现`AdminModule`**: 提供简单的命令行工具，允许管理员执行`list_proposals`, `review_proposal`, `approve_proposal`, `reject_proposal`等操作。
    3.  进行端到端测试，模拟一次完整的新事件发现、学习到应用的全过程。

---
*本文档旨在取代旧的、分散的需求文档，作为V2.0开发的核心指导。*

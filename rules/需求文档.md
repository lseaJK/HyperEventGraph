# HyperEventGraph V2.0: Agent驱动的智能图谱构建框架 - 需求文档

**版本**: 2.1 (AutoGen-based)
**作者**: Gemini Architect
**日期**: 2025-07-14

---

## 1. 核心愿景与设计原则

### 1.1 项目愿景

构建一个**自适应、自进化**的领域事件知识图谱系统。该系统不仅能从非结构化文本中深度抽取已知事件，还能通过Agent协作**自动发现、学习并掌握未知事件类型**，并**深度解析事件之间的复杂事理逻辑**，最终形成一个动态演进、持续增长的“活”知识库。

### 1.2 核心设计原则

- **Agent化 (Agent-Oriented)**: 将核心业务流程封装成具有明确角色的独立智能体(Agent)。
- **基于成熟框架 (Framework-Based)**: **采用微软的 `AutoGen` 作为核心框架**，用于Agent的定义、通信和工作流编排，确保系统的稳定性和可扩展性。
- **事件驱动 (Event-Driven)**: 整个工作流由数据的流入和状态变化来驱动，实现高度自动化。
- **可配置与可扩展 (Configurable & Extensible)**: 所有Agent的行为、Prompt和模型选择都通过外部配置文件管理。
- **人机协同 (Human-in-the-Loop)**: 在关键的知识增长环节保留人工审核���点，确保系统的准确性。

---

## 2. V2.0 核心架构：基于AutoGen的协作模型

我们将采用`AutoGen`作为核心框架来构建和管理我们的Agent团队。原先设想的`WorkflowController`将被`AutoGen`的内置工作流管理器（如`GroupChat`或`GraphFlow`）所取代。

![AutoGen-based Architecture](https://i.imgur.com/your-autogen-diagram.png) <!-- 这是一个占位符，建议后续生成架构图替换 -->

### 2.1 核心组件

- **`UserProxyAgent` (AutoGen)**:
  - **定位**: 用户的代理和人机交互的入口。
  - **职责**: 负责发起任务，并将需要人工审核的中间结果（如`SchemaLearnerAgent`的产出）呈报给人类专家。

- **`TriageAgent` (src/agents/triage_agent.py)**:
  - **实现为**: `autogen.AssistantAgent` 的子类。
  - **职责**: 接收`UserProxyAgent`的任务，对文本进行快速分类，判断事件是“已知”还是“未知”，然后将控制权交还给`GroupChat`管理器。

- **`ExtractionAgent` (src/agents/extraction_agent.py)**:
  - **实现为**: `autogen.AssistantAgent` 的子类。
  - **职责**: 当被调用时，根据指定的精确Schema进行深度、完整的结构化信息抽取。

- **`RelationshipAnalysisAgent` (src/agents/relationship_analysis_agent.py)**:
  - **实现为**: `autogen.AssistantAgent` ��子类。
  - **职责**: 分析多个事件之间的逻辑关系，为图谱生成“边”。

- **`StorageAgent` (src/agents/storage_agent.py)**:
  - **实现为**: `autogen.AssistantAgent` 的子类，但主要封装非LLM的工具。
  - **职责**: 接收最终的事件和关系数据，并调用`src/storage`中的函数将其持久化到Neo4j和ChromaDB。

- **`SchemaLearnerAgent` (src/agents/schema_learner_agent.py)**:
  - **实现为**: `autogen.AssistantAgent` 的子类，运行在独立的后台流程中。
  - **职责**: 与`UserProxyAgent`协作，在后台完成未知事件的聚类、学习和新Schema的生成。

---

## 3. 基于AutoGen的工作流详解

我们将使用`AutoGen`的`GroupChat`或`GraphFlow`来定义和执行工作流，取代之前设想的硬编码控制器。

### 3.1 实时处理工作流

可以定义一个`SelectorGroupChat`，由一个“Planner”Agent根据对话历史来决定下一步调用哪个Agent。

**工作流伪代码描述:**

```python
# 1. 初始化所有Agent
user_proxy = UserProxyAgent(...)
triage_agent = TriageAgent(...)
extraction_agent = ExtractionAgent(...)
relationship_agent = RelationshipAnalysisAgent(...)
storage_agent = StorageAgent(...)

# 2. 定义一个GroupChat来管理流程
#    可以使用SelectorGroupChat，让一个Planner Agent来决定流程
#    也可以自定义speaker_selection_func来实现更精细的控制
groupchat = GroupChat(
    agents=[user_proxy, triage_agent, extraction_agent, relationship_agent, storage_agent],
    messages=[],
    ...
)
manager = GroupChatManager(groupchat=groupchat, llm_config=...)

# 3. 用户发起任务
user_proxy.initiate_chat(
    manager,
    message="请处理这篇新闻文本: '...'",
)
```

**对话流程示例:**

1.  **UserProxyAgent** -> **GroupChat**: "请处理这篇新闻文本: '...'"
2.  **GroupChat Manager (Planner)** -> **TriageAgent**: "请对文本进行分类。"
3.  **TriageAgent** -> **GroupChat**: "分类结果：已知事件，类型为'企业收购'。"
    *   *(如果为未知，则TriageAgent会说"未知事件，已记录"，流程结束)*
4.  **GroupChat Manager (Planner)** -> **ExtractionAgent**: "请对文本进行'企业收购'事件的抽取。"
5.  **ExtractionAgent** -> **GroupChat**: "抽取完成，得到1个事件对象: `[event_obj]`"
6.  **GroupChat Manager (Planner)** -> **RelationshipAnalysisAgent**: "请对事件列表进行关系分析。"
7.  **RelationshipAnalysisAgent** -> **GroupChat**: "关系分析完成，发现0个关系。"
8.  **GroupChat Manager (Planner)** -> **StorageAgent**: "请将事件和关系存入数据库。"
9.  **StorageAgent** -> **GroupChat**: "数据已成功存储。任务完成。"
10. **GroupChat Manager (Planner)** -> **TERMINATE**

### 3.2 后台学习流程

这将是一个独立的`GroupChat`，主要由`SchemaLearnerAgent`和`UserProxyAgent`参与。

1.  **管理员 (通过UserProxyAgent)** -> **SchemaLearnerAgent**: "请开始学习新的事件类型。"
2.  **SchemaLearnerAgent**: (执行聚类) -> **UserProxyAgent**: "发现3个相似的未知事件簇，建议统一命名为'产品发布'，是否同意？"
3.  **管理员 (通过UserProxyAgent)** -> **SchemaLearnerAgent**: "同意。"
4.  **SchemaLearnerAgent**: (执行Schema归纳) -> **UserProxyAgent**: "已生成新的Schema，请审核: `{...}`"
5.  **管理员 (通过UserProxyAgent)** -> **SchemaLearnerAgent**: "审核通过。"
6.  **SchemaLearnerAgent**: (将Schema写入主文件) -> **UserProxyAgent**: "新Schema已添加。学习完成。"

---

## 4. 核心共享模块：实体知识库 (Entity Knowledge Base)

为了确保知识图谱中实体的一致性和准确性（例如，“宁德时代”和“CATL”应指向同一个节点），我们将建立一个独立、共享的**实体知识库（Entity KB）**。它不隶属于任何单个Agent，而是作为整个系统的核心基础设施存在，供所有需要实体标准化的Agent调用。

### 4.1 实体标准化混合策略

我们将采用一种兼具成本效益、准确性和自学习能力的混合策略：

1.  **第一层：本地知识库优先**
    - **机制**: 维护一个由人工审核过的、高质量的实体别名词典（例如，存储在 `config/entity_knowledge_base.yaml` 中）。
    - **优点**: 查询速度快、零成本、结果100%准确可控。此举将覆盖80%以上的高频常见实体。

2.  **第二层：LLM作为回退**
    - **机制**: 当一个实体在本地知识库中未找到时，才调用LLM进行上下文感知的识别和标准化。
    - **优点**: 灵活性强，能处理未记录的、罕见的或有错别字的实体名称。

3.  **第三层：人机协同学习闭环**
    - **机制**: LLM提出的新的实体-别名映射关系**不会被自动信任**���它将被存入一个“待审核列表”。
    - **流程**: `SchemaLearnerAgent`（或一个专门的管理流程）将辅助这个学习过程。它会收集这些待审核的建议，并在其后台学习流程中，一并提请人类专家进行审核。
    - **优点**: 保证了知识库的长期质量。通过这个闭环，本地知识库会不断丰富，从而逐渐降低对昂贵的LLM的依赖。

### 4.2 对Agent的影响

- **`ExtractionAgent` & `RelationshipAnalysisAgent`**: 在其工作流中，会调用实体知识库模块来标准化文本中出现的实体名称。
- **`SchemaLearnerAgent`**: 除了学习事件Schema，它还将负责**辅助维护实体知识库**，将LLM发现的新别名纳入其人机协同审核流程中。

---

## 5. 项目重构计划 (基于AutoGen)

- **第一阶段：环境与骨架搭建 (0.5周)**
    1.  **更新`requirements.txt`**: 添加`pyautogen`库。 (已完成)
    2.  **更新设计文档**: 明确所有Agent基于`AutoGen`实现。 (已完成)
    3.  **创建文件骨架**:
        - 创建`src/agents`和`src/admin`目录。
        - 创建`src/agents/{agent_name}.py`文件，每个文件中包含一个继承自`autogen.AssistantAgent`的空类。
        - 创建`src/admin/admin_module.py`。

- **第二阶段：Agent能力工具化 (2周)**
    1.  **封装`ExtractionAgent`工具**: 将`src/event_extraction`中的核心抽取逻辑，封装成一个或多个Python函数。这些函数将作为`ExtractionAgent`的`tools`进行注册。
    2.  **封装`RelationshipAnalysisAgent`工具**: 将`src/event_logic`中的关系分析、GraphRAG增强等逻辑，封装成`RelationshipAnalysisAgent`的`tools`。
    3.  **实现`TriageAgent`**: 为`TriageAgent`编写分类逻辑和记录未知事件的`tool`。
    4.  **实现`StorageAgent`**: 将`src/storage`的数据库操作封装成`StorageAgent`的`tools`。

- **第三阶段：工作流编排与测试 (1.5周)**
    1.  **定义`GroupChat`**: 在一个新的主流程脚本中，初始化所有Agent，并定义管理它们协作的`GroupChatManager`。
    2.  **编写测试用例**: 针对新的`GroupChat`工作流编写集成测试，覆盖已知事件、未知事件、多事件等场景。
    3.  **调试与优化**: 运行测试，调试Agent之间的对话流程和工具调用。

- **第四阶段：后台学习系统实现 (1.5周)**
    1.  **实现`SchemaLearnerAgent`**: 实现其聚类、归纳等核心`tools`。
    2.  **定义学习流程`GroupChat`**: 定义一个用于后台学习的、包含`SchemaLearnerAgent`和`UserProxyAgent`的`GroupChat`。
    3.  **实现`AdminModule`**: 提供一个简单的CLI（命令行界面），用于启动后台学习流程，并响应`UserProxyAgent`的审核请求。

---
*本文档旨在取代旧的、分散的需求文档，作为V2.0开发的核心指导。*
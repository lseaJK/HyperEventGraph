{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "第一阶段：环境与骨架搭建",
        "description": "根据需求文档V2.1，完成第一阶段的环境与骨架搭建。这包括更新依赖、确认设计文档、并创建所有必要的Agent和Admin模块的文件骨架。这个阶段为后续的Agent能力开发和工作流编排奠定基础。",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "第二阶段：Agent能力工具化",
        "description": "根据需求文档V2.1，完成第二阶段的Agent能力工具化。核心任务是将项目中现有的事件抽取、关系分析、分类和存储逻辑，封装成独立的Python函数，并作为“工具”注册给对应的Agent（ExtractionAgent, RelationshipAnalysisAgent, TriageAgent, StorageAgent）。",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          1
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "第三阶段：工作流编排与测试",
        "description": "根据需求文档V2.1，完成第三阶段的工作流编排与测试。主要工作是在一个主流程脚本中，使用AutoGen的GroupChatManager来初始化所有Agent，并定义它们之间的协作流程。同时，需要编写并运行集成测试，确保整个工作流在不同场景下都能稳定、正确地运行。",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          2
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "第四阶段：后台学习系统实现",
        "description": "根据需求文档V2.1，完成第四阶段的后台学习系统实现。这包括实现SchemaLearnerAgent的核心能力（如聚类、归纳），定义一个用于后台学习的独立GroupChat，并创建一个简单的管理模块（AdminModule）来启动学习流程和处理人工审核。",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          3
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "实现SchemaLearnerAgent的核心能力",
            "description": "实现SchemaLearnerAgent的聚类和归纳功能，并为这些核心功能编写单元测试以确保其正确性。",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 4
          },
          {
            "id": 2,
            "title": "定义并实现后台学习的GroupChat",
            "description": "基于AutoGen定义一个专用于后台学习的GroupChat，并进行配置，确保Agent可以在其中正确协作。编写初步的集成测试验证Chat的设置。",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 4
          },
          {
            "id": 3,
            "title": "创建AdminModule用于启动和审核",
            "description": "创建一个简单的AdminModule，提供启动后台学习流程的接口，并能接收学习结果以供人工审核。此模块的功能需要通过测试验证。",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 4
          },
          {
            "id": 4,
            "title": "集成并测试后台学习系统",
            "description": "将SchemaLearnerAgent, GroupChat, 和AdminModule集成在一起，形成完整的后台学习工作流。编写端到端测试，模拟一次完整的学习、审核流程，确保系统稳定运行。",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 4
          }
        ]
      },
      {
        "id": 5,
        "title": "第五阶段：重构事件抽取和验证模块",
        "description": "重构事件抽取和验证模块，以提高准确性和可维护性。这可能包括重新设计Schema、改进抽取逻辑或增强验证步骤。",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "建立统一的Pydantic Schema作为唯一真实来源",
            "description": "让 schemas.py 成为事件定义的唯一真实来源 (Single Source of Truth)。基于 event_schemas.json 的结构，在 schemas.py 中创建或完善所有事件的 Pydantic 模型。添加一个工具函数，可以从 Pydantic 模型动态生成 JSON Schema。",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 5
          },
          {
            "id": 2,
            "title": "定义抽取器抽象基类(BaseEventExtractor)",
            "description": "解耦服务和具体的抽取器实现。创建一个 base_extractor.py 文件，在其中定义一个抽象基类 BaseEventExtractor，并规定所有抽取器都必须实现的核心方法（如 extract）。",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 5
          },
          {
            "id": 3,
            "title": "使验证器适配Pydantic并集成deepseek-chat",
            "description": "简化验证流程。改造 EventExtractionValidator，使其直接使用 schemas.py 中的 Pydantic 模型进行验证，而不是读取外部 JSON 文件。在需要时集成 deepseek-chat 进行名称匹配。",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 5
          },
          {
            "id": 4,
            "title": "重构 EventExtractionService 以实现依赖注入",
            "description": "实现依赖注入，降低耦合。修改 EventExtractionService 的构造函数，使其不再自己创建实例，而是接收一个 BaseEventExtractor 类型的对象作为参数。",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 5
          },
          {
            "id": 5,
            "title": "适配 DeepSeekEventExtractor 以符合新接口",
            "description": "使现有实现符合新标准。让 DeepSeekEventExtractor 继承自新的 BaseEventExtractor，并确保其返回的数据是 schemas.py 中定义的 Pydantic 模型实例。在需要时利用 deepseek-chat 进行实体标准化。",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 5
          },
          {
            "id": 6,
            "title": "清理冗余文件和代码",
            "description": "移除废弃内容。在所有重构完成后，安全地删除 event_schemas.json 和旧的 extractor.py。",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 5
          },
          {
            "id": 7,
            "title": "更新单元测试以匹配新架构",
            "description": "确保新架构的稳定性。更新所有受影响的单元测试，以匹配新的类构造方式和数据返回类型。",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 5
          }
        ]
      },
      {
        "id": 6,
        "title": "重构实体去重模块以集成LLM进行智能标准化",
        "description": "重构实体去重模块(EntityDeduplicator)，集成大模型能力以提高名称标准化的准确性。当前模块过于依赖固定的后缀规则，导致对'Tencent Holdings'等名称的错误处理。新的实现将采用混合策略：优先使用保守的规则进行快速处理，对于复杂情况则调用大模型进行智能判断。",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "修改 EntityDeduplicator 构造函数以支持 LLM 客户端",
            "description": "更新 EntityDeduplicator 的 __init__ 方法，使其能够接收并存储一个LLM客户端实例。",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 6
          },
          {
            "id": 2,
            "title": "实现 LLM 驱动的名称标准化方法",
            "description": "创建 _normalize_name_with_llm 方法，该方法将使用few-shot prompt调用LLM来获取标准化的实体名称。",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 6
          },
          {
            "id": 3,
            "title": "在匹配函数中集成 LLM 标准化逻辑",
            "description": "在 _exact_match_score 和 _alias_match_score 中引入调用新LLM标准化方法的逻辑。",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 6
          },
          {
            "id": 4,
            "title": "更新单元测试以覆盖新逻辑",
            "description": "更新并添加单元测试，以验证新的规则和LLM标准化逻辑。",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 6
          }
        ]
      },
      {
        "id": 7,
        "title": "重构工作流以支持异步、文件驱动的人机交互",
        "description": "将一次性的 `run_agent_workflow.py` 脚本重构为一个可中断、可恢复的异步工作流。该工作流将通过状态文件和审核文件与用户进行交互，以适应用户无法实时在线的场景。",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "设计并实现状态管理系统",
            "description": "创建 workflow_state.json 的数据结构。实现加载和保存工作流状态的函数，包括当前阶段、输入文件路径、分流结果、已抽取的事件和关系等。",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 7
          },
          {
            "id": 2,
            "title": "创建主工作流控制器",
            "description": "开发新的 run_async_workflow.py 脚本。该脚本将作为工作流的唯一入口点，负责读取状态、调度不同阶段的执行，并处理用户回复。",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 7
          },
          {
            "id": 3,
            "title": "重构“分流”阶段为异步模块",
            "description": "将 TriageAgent 的逻辑封装成一个独立的函数。该函数执行后，会更新状态文件，并生成一个 review_request.txt，要求用户确认事件分类。",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 7
          },
          {
            "id": 4,
            "title": "重构“抽取”阶段为异步模块",
            "description": "将 ExtractionAgent 的逻辑封装成一个独立的函数。该函数在用户确认分流后执行，将抽取的事件写入状态文件，并生成一个新的 review_request.txt，要求用户审核或修正抽取结果。",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 7
          },
          {
            "id": 5,
            "title": "重构“关系分析与存储”阶段",
            "description": "将 RelationshipAnalysisAgent 和 StorageAgent 的逻辑合并为一个最终处理函数。该函数在用户确认抽取结果后执行，完成关系分析、数据存储，并最终将工作流状态标记为“完成”。",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 7
          },
          {
            "id": 6,
            "title": "实现用户反馈处理逻辑",
            "description": "在主控制器中，开发用于解析 review_response.txt 的功能。根据用户的回复（例如，status: CONFIRMED 或 data: [...]），更新 workflow_state.json。",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 7
          },
          {
            "id": 7,
            "title": "编写用户操作指南",
            "description": "创建一个 README_ASYNC.md 文件，清晰地说明如何启动新工作流、如何查看审核请求，以及如何编写回复文件来与系统互动。",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 7
          }
        ]
      },
      {
        "id": 8,
        "title": "Task #1: 稳健的批量初筛",
        "description": "开发 run_batch_triage.py。核心要求：1. 实现批处理和检查点机制。2. 必须动态加载最新的事件Schema来执行分类。3. 输出单一的、待审核的 triage_pending_review.jsonl 文件。",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Task #2: 人类智慧网关 - 离线审核",
        "description": "开发审核辅助脚本 (prepare_review_file.py 和 process_review_results.py)，并定义清晰的CSV审核流程。目标是高效地将AI的初步分类转化为高质量的、经过人类校准的 final_known_events.jsonl 和 final_unknown_events.jsonl。",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          8
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Task #3: 知识增长引擎 - 交互式学习",
        "description": "开发 run_learning_workflow.py。该脚本读取 final_unknown_events.jsonl，通过人机交互指导 SchemaLearnerAgent 完成学习，并将新学会的Schema更新到核心的 event_schemas.json 文件中，为系统的下一次迭代提供增长。",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          9
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Task #4: 价值实现 - 批量抽取",
        "description": "开发 run_extraction_workflow.py。该脚本读取高质量的 final_known_events.jsonl，对所有已知事件进行批量化、结构化的信息抽取，产出可直接用于图谱构建的 structured_events.jsonl。",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          9
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Task #1: 奠定基石 - 建立中央状态库与配置文件",
        "description": "1. 设计并创建`master_state.db` (SQLite)，用于追踪每个数据点的生命周期状态。2. 创建唯一的`config.yaml`中央配置文件，管理所有路径、批次大小、模型名称等参数。3. 开发一个所有其他脚本都将引用的配置加载模块。",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Task #2: 实施第一阶段 - 开发与状态库集成的批量初筛工作流",
        "description": "开发`run_batch_triage.py`。它必须：1. 从`config.yaml`读取配置。2. 从`master_state.db`查询状态为`pending_triage`的数据。3. 在分类时引入置信度分数。4. 将分类结果和置信度写回`master_state.db`，并更新状态为`pending_review`。",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          12
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Task #3: 实施第二阶段 - 开发支持优先级的离线人工审核工作流",
        "description": "开发审核辅助脚本。`prepare_review_file.py`需从数据库查询待审核数据，并根据置信度排序生成CSV。`process_review_results.py`需读取审核后的CSV，并将最终结果更新回`master_state.db`，设置状态为`pending_learning`或`pending_extraction`。",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          13
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Task #4: 实施第三阶段 - 开发增强型交互式学习工作流",
        "description": "开发`run_learning_workflow.py`。它必须：1. 从数据库查询待学习数据。2. 实现更丰富的交互指令(如`show_samples`, `merge_clusters`)。3. 在学会新Schema后，将`event_schemas.json`更新，并把对应数据的状态在数据库中重置为`pending_triage`，以闭合知识循环。",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          14
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 16,
        "title": "Task #5: 实施第四阶段 - 开发批量抽取工作流",
        "description": "开发`run_extraction_workflow.py`。它从`master_state.db`查询状态为`pending_extraction`的数据，进行批量抽取，并将最终的结构化数据存入指定位置，同时在数据库中将任务状态更新为`completed`。",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          14
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 17,
        "title": "系统优化与文档完善",
        "description": "对系统进行持续优化，并创建和维护关键技术文档，以提高项目的可维护性和可理解性。",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          16
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "创建Prompt调优指南",
            "description": "创建 PROMPT_TUNING_GUIDE.md 文件，详细说明所有LLM调用场景、目标、提示词和预期输出，为模型优化和选型提供依据。",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 17
          }
        ]
      },
      {
        "id": 18,
        "title": "Task #18: 实现关系分析与知识存储层",
        "description": "实现一个全新的处理层，负责分析已抽取事件之间的逻辑关系，并将事件节点和关系边持久化地存储到双数据库（图数据库和向量数据库）中，为构建知识图谱奠定基础。",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          17
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "V4.0详细设计规划 - 关系分析与知识存储",
            "description": "根据架构师与管理者的讨论，Task #18的具体实现细节如下：1. **新工作流**: 创建`run_relationship_analysis.py`作为抽取后的新阶段。2. **关系分析**: `RelationshipAnalysisToolkit`将使用LLM分析事件间的关系，关系类型体系定义为：`Causal` (因果), `Temporal` (时序), `Sub-event` (从属), `Elaboration` (阐述), `Contradiction` (矛盾), `Influence` (影响), `Related` (相关)。3. **图存储**: `GraphStorageAgent`负责将事件、实体节点和关系边写入图数据库。4. **向量存储**: `VectorStorageAgent`负责实现分层向量化策略，对`_source_text` (原文), `event.description` (事件描述), 和构造的`entity_centric_context` (实体中心上下文) 分别进行向量化并存入ChromaDB。",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 18
          }
        ]
      },
      {
        "id": 19,
        "title": "Task #19: 开发混合检索器并闭合知识循环",
        "description": "开发一个能够同时查询图数据库和向量数据库的混合检索器（HybridRetrieverAgent），并将其集成到现有的抽取和分析工作流中，通过为LLM提供丰富的历史上下文来增强其处理精度，从而闭合知识反馈循环。",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          18
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "V4.0详细设计规划 - 混合检索与知识闭环",
            "description": "根据架构师与管理者的讨论，Task #19的具体实现细节如下：1. **触发时机**: 优先在`run_relationship_analysis.py`工作流中引入混合检索。2. **核心Agent**: 实现`HybridRetrieverAgent`作为“情报分析师”。3. **检索策略**: Agent需对新文本进行初步实体识别，然后**并行**查询双数据库：a) **图数据库**: 基于核心实体进行精确的、结构化的关系与事件查询。b) **向量数据库**: 基于全文向量进行模糊的、语义相似的事件案例查询。4. **上下文整合与Prompt增强**: Agent将检索到的图谱事实和相似案例整合成一段简洁的“背景摘要”，并将其注入到关系分析任务的Prompt中，为LLM提供决策参考，实现知识闭环。",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 19
          }
        ]
      },
      {
        "id": 20,
        "title": "Task #20: 并行执行全量数据的初步事件抽取",
        "description": "为了提高项目效率，在V4.0的关系分析与知识图谱功能开发的同时，并行地对全量数据（来自IC_data/filtered_data.json）执行初步的事件抽取。此任务的目标是生成一个临时的、包含所有原子事件的structured_events.jsonl文件，为后续的知识图谱构建提供原材料，并提前暴露Prompt在多样化数据上的表现。",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          19
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 21,
        "title": "Task #21: 对10%初步事件抽取结果进行全面分析与技术验证",
        "description": "基于已完成的10%全量数据抽取结果（docs/output/structured_events.jsonl），执行一次全面的初步分析与处理，旨在校验数据质量、摸清数据特征，并对后续核心任务（Task #18, #19）进行技术原型验证。分析内容包括：1. 数据质量与完整性校验；2. 核心实体与关系分析；3. 事件类型与分布分析；4. 定量数据解析；5. 构建微型知识图谱与向量检索原型，为V4.0的开发扫清障碍。",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "数据质量审查与特征分析",
            "description": "定量地、全面地理解我们初步抽取的数据质量和内在特征，发现潜在的数据问题和关键模式。具体包括：1. 创建`src/analysis/extraction_quality_analyzer.py`。2. 执行完整性校验、事件类型分布分析、高频实体分析和定量数据探查。3. 输出一份分析报告。",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 21
          },
          {
            "id": 2,
            "title": "构建微型知识图谱原型",
            "description": "验证将扁平的事件JSONL数据转化为相互关联的图结构的可行性。具体包括：1. 创建原型脚本`src/analysis/build_micro_graph.py`。2. 使用`networkx`在内存中构建图，将事件和实体创建为节点，并创建它们之间的关系边。3. 为`GraphStorageAgent`的开发提供一个经过验证的图数据模型。",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 21
          },
          {
            "id": 3,
            "title": "构建微型向量数据库原型",
            "description": "完整实现并验证需求文档中定义的“分层向量化策略”。具体包括：1. 增强`src/analysis/vector_search_prototype.py`。2. 使用`ChromaDB`，对每个事件生成并存储三种不同的向量表示：事件描述、实体中心上下文、原文片段。3. 为`VectorStorageAgent`的开发提供可以直接复用的代码。",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 21
          },
          {
            "id": 4,
            "title": "开发混合检索原型并闭合验证循环",
            "description": "模拟`HybridRetrieverAgent`的核心逻辑，证明结合图的精确查询和向量的模糊查询能产生更优越的检索结果。具体包括：1. 创建原型脚本`src/analysis/hybrid_retrieval_prototype.py`。2. 协同调用图谱和向量原型。3. 实现一个演示混合检索流程并输出融合结果的脚本，为`HybridRetrieverAgent`的开发提供逻辑蓝图。",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 21
          }
        ]
      },
      {
        "id": 22,
        "title": "优化抽取Prompt以捕获结构化定量数据",
        "description": "当前抽取流程无法将description中包含的金额、百分比、日期等信息有效提取到结构化的`quantitative_data`字段中。此任务的目标是：1. 分析`prompts/extraction.md`和相关抽取器代码，定位问题根源。2. 修改并优化Prompt，使其能够准确解析并填充`quantitative_data`字段。3. 通过小批量数据验证修复效果。",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "验证Prompt修复效果",
            "description": "使用小批量数据（例如，从 `IC_data/filtered_data.json` 中选取5-10条包含明确数量信息的样本）运行一次 `run_extraction_workflow.py`，并人工检查输出的 `structured_events.jsonl` 文件，确认 `quantitative_data` 字段是否已按预期被正确填充。",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 22
          }
        ]
      },
      {
        "id": 23,
        "title": "建立LLM调用的健壮性与可追溯性规范",
        "description": "此为一项规范型任务，定义了所有模块在调用大语言模型（LLM）时必须遵守的核心准则。要求：1. **保留原始输出**：完整记录LLM返回的原始数据。2. **分离解析结果**：使用try-except处理返回内容，成功的结果进入主数据流，失败的案例（含原始数据、错误信息等）必须记录到专门的“失败审查”位置（如独立的日志文件或数据表）。3. **关联ID**: 所有记录必须包含唯一的请求ID以便追溯。此规范将作为未来所有LLM相关功能开发的验收标准。",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 24,
        "title": "Task #21.1: 创建 Cortex 模块基础架构",
        "description": "创建 `run_cortex_workflow.py` 脚本文件和 `src/cortex/` 目录。定义核心组件的类骨架 (`VectorizationService`, `ClusteringOrchestrator`, `RefinementAgent`)。这是Cortex模块的初始化步骤。",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 25,
        "title": "Task #21.2: 实现 ClusteringOrchestrator 的算法粗聚类功能",
        "description": "实现从数据库读取待处理事件、调用向量化服务、计算实体加权距离、并使用DBSCAN算法进行聚类的核心逻辑。将聚类结果（`event_id` -> `cluster_id`）写入数据库。依赖 Task #21.1。",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          24
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Refactor vectorization to use local model",
            "description": "Refactor VectorizationService and related components to use a local sentence-transformers model instead of relying on an LLMClient for embeddings. This involves making the workflow synchronous.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 25
          }
        ]
      },
      {
        "id": 26,
        "title": "Task #21.3: 实现 RefinementAgent 的基础精炼功能",
        "description": "实现处理小规模“粗簇”的逻辑。开发 \"Refinement Prompt\"，调用LLM对簇进行分析，并返回“故事单元”。依赖 Task #21.1。",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          24
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 27,
        "title": "Task #21.4: 实现 RefinementAgent 的大簇处理策略",
        "description": "实现“摘要-检索-扩展”的迭代逻辑，以处理规模超过预设阈值的“粗簇”。依赖 RefinementAgent 的基础功能。",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          26
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 28,
        "title": "Task #21.5: 实现 Cortex 的批处理触发机制",
        "description": "修改 `run_extraction_workflow.py`，在脚本末尾添加 `check_and_trigger_cortex` 函数，实现基于阈值的自动调用。",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "low",
        "subtasks": []
      },
      {
        "id": 29,
        "title": "Task #21.6: 整合并测试端到端 Cortex 工作流",
        "description": "将所有组件整合到 `run_cortex_workflow.py` 中，并进行完整的端到端测试，确保从事件输入到生成“故事单元”状态的流程完全通畅。依赖粗聚类和精炼功能的完成。",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          25,
          27
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 30,
        "title": "执行全量数据事件抽取并监控完成情况",
        "description": "此任务用于追踪 `run_extraction_workflow.py` 在全量数据集上的执行过程。主要工作是监控其进度，确保其顺利完成，并处理在运行过程中可能出现的任何问题。",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 31,
        "title": "Task #31: 验证并完善知识迭代闭环",
        "description": "此任务旨在将我们在需求文档V4.0（4.7节）中定义的“知识迭代闭环”策略在代码层面完全实现并进行端到端验证。核心是确保系统在学会新知识后，能够自动将相关数据重新纳入处理流程，实现知识的自我增强。",
        "details": "1. **检查 `run_learning_workflow.py`**: 审查并确保该脚本在成功学习并保存新Schema后，会自动将所有相关的 `pending_learning` 事件状态重置为 `pending_triage`。\n2. **准备测试数据**: 从主数据集中选取或构造一小批（约50-100条）代表了某种新事件模式的“未知事件”，并手动将它们的状态在数据库中设置为 `pending_learning`。\n3. **执行学习工作流**: 运行 `run_learning_workflow.py`，与系统交互，完成新Schema的定义和保存。\n4. **验证状态重置**: 学习完成后，检查数据库，确认之前用于学习的事件状态是否已全部变回 `pending_triage`。\n5. **执行初筛工作流**: 运行 `run_batch_triage.py`，验证 `TriageAgent` 现在是否能够利用新学会的Schema，成功地将这些事件分类，并将其状态更新为 `pending_extraction`。\n6. **编写总结报告**: 将整个验证过程、结果和发现的问题记录在一份简短的Markdown报告中。",
        "testStrategy": "1. 单元测试：为 `run_learning_workflow.py` 中负责重置状态的函数编写单元测试。\n2. 集成测试：创建一个小型的测试数据库，模拟完整的“学习 -> 状态重置 -> 重新初筛”流程。\n3. 端到端验证：按照“实施细节”中的步骤进行完整的手动测试，并记录结果。",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 32,
        "title": "Task #32: 构建统一的系统管理CLI",
        "description": "当前系统由多个独立的Python脚本驱动，操作流程分散，对用户不友好。此任务旨在创建一个统一的命令行接口（CLI），将所有核心工作流（如初筛、学习、抽取、Cortex、关系分析）封装成子命令，提供一个单一的、专业的系统管理入口。",
        "details": "1. **选择CLI框架**: 采用 `argparse` 或更高级的库（如 `click` 或 `typer`）来构建CLI应用。\n2. **创建主入口脚本**: 创建一个新的主脚本，例如 `main.py` 或 `manage.py`。\n3. **封装工作流**: 将 `run_batch_triage.py`, `run_learning_workflow.py`, `run_extraction_workflow.py`, `run_cortex_workflow.py`, `run_relationship_analysis.py` 的核心逻辑封装成可以被主脚本调用的函数。\n4. **设计子命令**:\n   - `main.py triage`: 运行批量初筛工作流。\n   - `main.py learn`: 运行交互式学习工作流。\n   - `main.py extract`: 运行事件抽取工作流。\n   - `main.py cortex`: 手动触发Cortex故事发现工作流。\n   - `main.py analyze`: 运行关系分析与存储工作流。\n   - `main.py run-all`: 按正确顺序自动依次执行所有工作流。\n5. **添加辅助功能**: 在CLI中加入 `--help` 说明，并为每个子命令提供清晰的文档。\n6. **更新项目文档**: 更新 `README.md` 或创建一个新的 `CLI_GUIDE.md`，说明如何使用这个新的管理工具。",
        "testStrategy": "1. 为每个子命令编写独立的集成测试，验证其是否能成功调用正确的工作流。\n2. 手动测试所有CLI命令及其组合，确保其行为符合预期。\n3. 检查 `--help` 输出的清晰度和准确性。",
        "status": "done",
        "dependencies": [
          31
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 33,
        "title": "Architectural Refactoring: Implement Event-Centric Learning Workflow",
        "description": "Implement the new event-centric architecture for the interactive learning workflow. This involves changing the core clustering logic from document-level to event-level, updating all interactive commands (list, show, merge) to operate on event clusters, and creating a regrouping mechanism to map event clusters back to document clusters for schema generation and saving.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 34,
        "title": "Task #18: 实现关系分析与知识存储层",
        "description": "根据需求文档V4.0 (4.3.1节) 的定义，实现关系分析与知识存储层。此任务是构建知识图谱的核心。",
        "details": "1. **开发 `RelationshipAnalysisToolkit`**: 实现一个能够分析同一来源的事件组之间逻辑关系（因果、时序、子事件等）的工具包。2. **开发 `GraphStorageAgent`**: 将分析出的事件、实体和关系，分别作为节点和边，存入 Neo4j 图数据库。3. **开发 `VectorStorageAgent`**: 采用分层向量化策略，将原文、事件描述和实体中心上下文分别向量化，并存入 ChromaDB，以支持多维度的语义搜索。",
        "testStrategy": "1. 单元测试：为关系类型判断、节点/边生成、向量化策略等核心函数编写单元测试。2. 集成测试：创建一个小型的测试数据库和事件列表，验证从关系分析到双数据库存储的完整流程。3. 端到端验证：使用 `structured_events.jsonl` 的一个子集作为输入，手动运行工作流，并检查 Neo4j 和 ChromaDB 中的数据是否符合预期。",
        "status": "done",
        "dependencies": [
          30
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 35,
        "title": "Task #19: 开发混合检索器并闭合知识循环",
        "description": "根据需求文档V4.0 (4.3.2节) 的定义，开发混合检索器并闭合知识循环。此任务是实现系统“智能”的关键。",
        "details": "1. **开发 `HybridRetrieverAgent`**: 创建一个核心 Agent，其职责是在处理新信息前，从双数据库中检索相关的历史背景。2. **实现混合检索策略**: 对新文本进行实体识别，然后并行地从图数据库进行结构化事实查询，并从向量数据库进行语义相似案例查询。3. **实现知识闭环**: 将检索到的图谱事实和相似案例整合成“背景摘要”，并将其注入到关系分析任务的 Prompt 中，为 LLM 提供决策参考，实现知识增强。",
        "testStrategy": "1. 单元测试：为混合检索策略中的图查询和向量查询部分编写单元测试。2. 集成测试：构建一个包含少量知识的测试数据库，验证 `HybridRetrieverAgent` 是否能根据新输入正确检索并生成“背景摘要”。3. 端到端验证：在关系分析工作流中激活该 Agent，对比启用和禁用知识反哺时，LLM 对同一组复杂事件关系判断的准确性差异。",
        "status": "done",
        "dependencies": [
          34
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 36,
        "title": "Task #36: [Epic] 构建Web可视化界面",
        "description": "开发一个基于Web的图形用户界面（GUI），作为HyperEventGraph系统的控制面板和知识浏览器。该界面将提供文件上传、工作流监控和结果可视化功能。",
        "details": "此任务是一个高级“史诗”任务，涵盖了从API开发到前端实现的所有方面。具体的子任务将详细说明每个模块的开发。技术栈将采用FastAPI（后端API）和React（前端）。",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Task #36.1: 开发FastAPI后端服务",
            "description": "使用FastAPI创建一个新的Python后端服务，作为Web前端和现有工作流之间的API层。",
            "details": "1. 设置FastAPI项目结构。2. 创建一个 `/status` 端点，用于从 `master_state.db` 查询并返回各类事件的数量。3. 为每个核心工作流（triage, extract等）创建 `/workflow/{workflow_name}/start` 端点，用于通过子进程调用相应的脚本。4. 实现WebSocket端点，用于从正在运行的工作流中广播实时进度更新。",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 36
          },
          {
            "id": 2,
            "title": "Task #36.2: 搭建React前端框架",
            "description": "搭建React前端项目的基本框架和结构。",
            "details": "1. 使用 `create-react-app` 或 `vite` 初始化一个新的React项目。2. 安装并配置核心依赖：Material-UI (MUI), Recharts, react-force-graph, 和用于WebSocket通信的库。3. 创建一个基本的应用布局，包括一个固定的侧边导航栏和一个主内容区域。",
            "status": "done",
            "dependencies": [
              "36.1"
            ],
            "parentTaskId": 36
          },
          {
            "id": 3,
            "title": "Task #36.3: 实现Dashboard概览页面",
            "description": "开发Dashboard主页，用于展示系统概览。",
            "details": "1. 创建Dashboard页面组件。2. 调用后端的 `/status` 端点获取数据。3. 使用Recharts的PieChart组件将数据状态可视化。4. 使用MUI的Card组件展示关键性能指标（KPIs）。",
            "status": "done",
            "dependencies": [
              "36.2"
            ],
            "parentTaskId": 36
          },
          {
            "id": 4,
            "title": "Task #36.4: 实现工作流控制中心",
            "description": "开发工作流控制中心页面。",
            "details": "1. 创建Workflow页面组件。2. 为每个工作流设计一个控制卡片，包含状态显示和“Run”按钮。3. 将“Run”按钮连接到后端的 `/workflow/{workflow_name}/start` 端点。4. 实现一个日志面板，连接到WebSocket端点，以实时显示来自后端脚本的进度和输出。",
            "status": "done",
            "dependencies": [
              "36.2"
            ],
            "parentTaskId": 36
          },
          {
            "id": 5,
            "title": "Task #36.5: 实现知识浏览器",
            "description": "开发知识浏览器，用于可视化和查询结果。",
            "details": "1. 创建Knowledge Explorer页面，包含两个可切换的视图（Table/Graph）。2. **Table View**: 实现一个API端点，用于分页、排序和过滤 `structured_events.jsonl` 的内容。在前端使用MUI的DataTable组件展示数据。3. **Graph View**: 实现一个API端点，用于从Neo4j中查询事件、实体和关系，并将其格式化为图形数据（nodes and links）。在前端使用 `react-force-graph` 将数据可视化。4. 添加一个搜索框，允许用户通过实体名称在图中高亮显示相关节点。",
            "status": "done",
            "dependencies": [
              "36.2"
            ],
            "parentTaskId": 36
          }
        ]
      },
      {
        "id": 37,
        "title": "V1-Task1: 开发 FastAPI 后端服务",
        "description": "搭建 FastAPI 后端服务的基础框架。实现所有 V1 设计中定义的 RESTful API 端点（如 /api/status, /api/events, /api/graph）和用于实时日志推送的 WebSocket 端点。此任务是前后端通信的基石，必须最先完成。",
        "details": "1. 初始化 FastAPI 项目。\n2. 实现 `GET /api/status`，用于从 master_state.db 读取全局状态。\n3. 实现 `POST /api/workflow/{workflow_name}/start`，用于通过 `subprocess` 启动后端脚本。\n4. 实现 `GET /api/events`，用于分页读取 `structured_events.jsonl`。\n5. 实现 `GET /api/graph`，用于从 Neo4j 查询图数据。\n6. 实现 `/ws/logs` WebSocket 端点，用于实时推送日志。\n7. 编写基础的 API 文档 (Swagger/OpenAPI)。",
        "testStrategy": "使用 FastAPI 的测试客户端编写单元测试，验证每个 API 端点的响应是否符合预期。\n模拟工作流脚本的启动和日志输出，测试 WebSocket 的实时推送功能。",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 38,
        "title": "V1-Task2: 搭建 React 前端框架与基础布局",
        "description": "初始化 React 前端项目，并集成核心的 UI 和可视化库。构建应用的基础布局，包括顶部导航栏、侧边菜单和主内容区域，为后续功能页面的开发提供一个稳定的容器。",
        "details": "1. 使用 `create-react-app` 或类似工具初始化项目。\n2. 安装并配置 Material-UI (MUI) 作为核心组件库。\n3. 安装并配置 `react-force-graph` 用于知识图谱可视化。\n4. 安装 `socket.io-client` 用于 WebSocket 通信。\n5. 设计并实现应用的主体布局（App Layout），包括 Header, Sidebar, 和 Content Area。\n6. 设置前端路由（如 `react-router-dom`）。",
        "testStrategy": "在 Storybook 中为基础布局组件（如 Header, Sidebar）编写单元故事。\n运行应用，确保基础布局在不同屏幕尺寸下能正确响应。",
        "status": "done",
        "dependencies": [
          37
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 39,
        "title": "V1-Task3: 实现 Dashboard 概览页面",
        "description": "开发前端的 Dashboard 概览页面。该页面作为用户进入系统的首页，需要通过调用后端 API，将系统的宏观健康状态和数据统计信息以直观的图表和卡片形式展示出来。",
        "details": "1. 创建 Dashboard 页面组件。\n2. 在页面加载时，调用 `GET /api/status` API。\n3. 使用 MUI 的 Card 和 Chart 组件（或集成一个轻量级图表库）来展示数据。\n4. 设计并实现“全局状态概览”饼图或统计卡片。\n5. 设计并实现“工作流实时状态”的展示区域。\n6. 将 Dashboard 页面集成到主应用路由中。",
        "testStrategy": "使用 mock 数据对 Dashboard 组件进行单元测试。\n与真实的后端 API 对接，进行端到端测试，确保数据能正确获取和渲染。",
        "status": "done",
        "dependencies": [
          37,
          38
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 40,
        "title": "V1-Task4: 实现工作流控制中心",
        "description": "开发工作流控制中心页面。用户应能在此页面看到所有核心工作流的列表，并能手动触发任何一个工作流的执行。页面还需要包含一个实时日志窗口，通过 WebSocket 连接后端，动态显示当前正在运行的工作流的输出。",
        "details": "1. 创建 Workflow Control Center 页面组件。\n2. 遍历工作流列表，为每个工作流创建一个控制卡片，包含“启动”按钮。\n3. 实现点击“启动”按钮时，调用 `POST /api/workflow/{workflow_name}/start` API。\n4. 实现一个实时日志显示组件（Log Console）。\n5. 在组件加载时，建立到 `/ws/logs` 的 WebSocket 连接。\n6. 监听 WebSocket 消息，并将接收到的日志行追加到 Log Console 中。\n7. 处理 WebSocket 的连接、断开和错误状态。",
        "testStrategy": "对“启动”按钮的 API 调用进行单元测试。\n对 Log Console 组件进行单元测试，验证其能正确接收和渲染日志行。\n进行端到端测试，实际启动一个后端脚本，观察日志是否能被实时、完整地推送到前端。",
        "status": "done",
        "dependencies": [
          37,
          38
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 41,
        "title": "V1-Task5: 实现知识浏览器 (事件表格与图谱)",
        "description": "开发知识浏览器页面。此页面是系统核心价值的出口，包含两部分：一个用于展示和检索所有结构化事件的数据表格，以及一个用于可视化事件与实体关系的交互式知识图谱。",
        "details": "1. 创建 Knowledge Browser 页面组件，并设计 Tab 布局（表格/图谱）。\n2. **数据表格部分**:\n   - 使用 MUI 的 `DataGrid` 组件。\n   - 实现调用 `GET /api/events` API 来获取数据。\n   - 实现分页、排序和搜索功能。\n3. **知识图谱部分**:\n   - 使用 `react-force-graph` 组件。\n   - 实现调用 `GET /api/graph` API 来获取图数据（节点和边）。\n   - 实现图谱的缩放、平移和节点点击交互（如高亮、显示详情）。\n   - 添加一个搜索框，用于在图谱中快速定位节点。",
        "testStrategy": "使用 mock 数据分别对数据表格和知识图谱组件进行单元测试。\n与真实后端 API 对接进行端到端测试，确保事件数据和图数据能被正确加载和渲染。\n测试图谱的交互性能，确保在千个节点规模下依然流畅。",
        "status": "done",
        "dependencies": [
          37,
          38
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 42,
        "title": "V2-Task1: 实现过程干预能力 (停止/暂停/恢复)",
        "description": "实现对正在运行的工作流进行生命周期管理的高级控制功能。这需要扩展 FastAPI 后端和前端控制中心，允许用户停止、暂停和恢复一个工作流进程。",
        "details": "1. **后端**:\n   - 维护一个进程注册表（如一个全局字典），存储 `workflow_name` 到 `subprocess.Popen` 对象的映射。\n   - 实现 `POST /api/workflow/{workflow_name}/stop` API，通过发送 `SIGTERM` 信号终止进程。\n   - (可选) 实现 `pause` 和 `resume` API，通过发送 `SIGSTOP` 和 `SIGCONT` 信号。\n2. **前端**:\n   - 在工作流控制中心，当一个任务正在运行时，将“启动”按钮变为“停止”、“暂停”等按钮组。\n   - 实现点击这些按钮时调用对应的 V2 API。\n   - 更新UI状态以反映任务的暂停或终止。",
        "testStrategy": "后端单元测试：验证调用 stop API 后，目标子进程确实被终止。\n前端单元测试：验证按钮状态在任务运行时会正确切换。\n端到端测试：启动一个长时间运行的脚本（如 `sleep 30`)，然后通过UI点击停止按钮，确认脚本提前终止。",
        "status": "done",
        "dependencies": [
          37,
          40
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 43,
        "title": "V2-Task2: 实现动态配置能力",
        "description": "允许用户在启动工作流前，通过 UI 动态调整该工作流的关键参数，而无需修改后端的配置文件。这极大地提升了系统的灵活性和易用性。",
        "details": "1. **后端**:\n   - 修改 `POST /api/workflow/{workflow_name}/start` API，使其可以接受一个可选的配置参数（JSON body）。\n   - 修改 FastAPI 服务逻辑，在启动子进程时，将接收到的配置通过命令行参数（如 `--model-name glm-4.5-air`）或环境变量的方式传递给脚本。\n   - 后端工作流脚本需要修改为能够解析这些传入的参数，并覆盖默认配置。\n2. **前端**:\n   - 在工作流控制中心，点击“启动”按钮时，弹出一个配置对话框（Modal）。\n   - 在对话框中，根据工作流类型动态生成配置表单（如模型选择下拉框、批处理大小输入框）。\n   - 用户确认后，将表单数据作为请求体发送给 `start` API。",
        "testStrategy": "后端单元测试：验证使用不同配置参数调用 start API 时，子进程能接收到正确的命令行参数。\n前端单元测试：验证配置对话框能正确生成和提交表单数据。\n端到端测试：通过UI修改一个参数（如输出文件名），启动工作流，然后检查后端生成的文件名是否与UI中指定的一致。",
        "status": "done",
        "dependencies": [
          37,
          40
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 44,
        "title": "V2-Task3: 实现错误处理与恢复机制",
        "description": "增强系统的容错能力。当工作流执行失败时，为用户提供清晰的错误报告，并提供方便的恢复机制，如一键重试或从断点继续。",
        "details": "1. **后端**:\n   - 工作流脚本需要实现更健壮的 `try...except` 块，并将详细的错误信息（包括堆栈跟踪）结构化地写入数据库或专门的日志文件。\n   - 实现一个新的 API `GET /api/workflow/{workflow_name}/error_report`，用于读取和返回格式化的错误信息。\n   - 修改工作流脚本以支持断点续传（例如，通过记录已处理的批次ID）。\n2. **前端**:\n   - 在工作流控制中心，当任务状态为 `Failed` 时，显示一个“查看错误”按钮。\n   - 点击按钮时，调用 error_report API 并将错误信息显示在对话框中。\n   - 在错误报告对话框中，提供“一键重试”按钮，该按钮再次调用 `start` API。",
        "testStrategy": "后端测试：故意在工作流脚本中引入一个错误，运行后检查错误是否被正确捕获并记录。验证 error_report API 能返回该错误。\n前端测试：Mock 一个失败的任务状态和错误报告，验证UI能正确展示。\n端到端测试：触发一个会失败的任务���通过UI查看错误报告，然后点击重试，验证任务是否能重新执行。",
        "status": "pending",
        "dependencies": [
          37,
          40
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 45,
        "title": "V2-Task4: 实现数据与版本管理",
        "description": "对输入数据和输出结果进行版本化管理，以支持回溯和对比分析。这需要对数据模型和API进行扩展，引入“批次”或“快照”的概念。",
        "details": "1. **后端 (数据模型)**:\n   - 扩展数据库模式，引入 `Batch` 或 `Snapshot` 表。\n   - 所有核心数据表（如 `MasterState`, `StructuredEvents`）增加一个 `batch_id` 外键。\n2. **后端 (API)**:\n   - 修改所有数据查询 API（如 `GET /api/events`, `GET /api/graph`），增加一个可选的 `batch_id` 参数，用于查询特定版本的数据。\n   - 实现一个新的 API `GET /api/batches`，用于获取所有可用的数据批次列表。\n3. **前端**:\n   - 在知识浏览器等页面，添加一个下拉菜单，允许用户选择要查看的数据批次。\n   - 当用户切换批次时，重新调用数据获取 API 并传入所��的 `batch_id`。",
        "testStrategy": "后端测试：验证使用 `batch_id` 参数调用 API 时，返回的数据被正确过滤。\n前端测试：验证批次下拉菜单能正确加载和切换。\n端到端测试：创建两个不同的数据批次，通过UI切换，验证页面内容（表格和图谱）相应地更新。",
        "status": "pending",
        "dependencies": [
          37,
          41
        ],
        "priority": "low",
        "subtasks": []
      },
      {
        "id": 46,
        "title": "FE-Task1: 创建API服务层",
        "description": "根据V1设计文档，在 `frontend/src` 下创建 `services/api.ts` 模块。使用axios或fetch配置一个集中的API客户端实例，并为所有后端端点（如 /api/status, /api/events, /api/graph, /api/workflow/{name}/start）创建对应的请求函数。这是连接所有前端组件与后端的桥梁。",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          37
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 47,
        "title": "FE-Task2: 引入并配置全局状态管理 (Zustand)",
        "description": "为了解决跨组件数据共享问题，引入一个轻量级的全局状态管理库（推荐Zustand）。在 `frontend/src/store/` 目录下创建 `systemStore.ts` 用于管理系统宏观状态和工作流列表，以及 `logStore.ts` 用于存放从WebSocket接收的实时日志。",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          38
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 48,
        "title": "FE-Task3: 搭建核心UI组件库 (MUI)",
        "description": "安装Material-UI (MUI) 库。在 `frontend/src/components/common/` 目录下，创建一套可被多处复用的基础UI组件，例如 PageLayout.tsx (包含导航与侧边栏)、StyledCard.tsx (统一样式卡片) 和 StatusChip.tsx (用于显示pending, running等状态)，以确保应用视觉风格的统一并加速开发。",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          38
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 49,
        "title": "FE-Task4: 实现Dashboard概览页面",
        "description": "开发 `frontend/src/pages/DashboardPage.tsx`。此页面作为应用的首页，需要连接Zustand store和API服务层，定期获取并以图表（如MUI或Recharts的饼图）和指标卡片的形式，动态展示系统的宏观健康状况与数据统计。",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          46,
          47,
          48
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 50,
        "title": "FE-Task5: 实现工作流控制中心",
        "description": "开发 `frontend/src/pages/WorkflowControlPage.tsx`。此页面包含两部分核心功能：1) 一个工作流列表，每项都有“启动”按钮，点击后调用API服务。2) 一个实时日志显示窗口，在组件加载时建立WebSocket连接，并将收到的日志动态渲染到界面上。",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          46,
          47,
          48
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 51,
        "title": "FE-Task6: [Epic] 实现知识浏览器",
        "description": "开发 `frontend/src/pages/KnowledgeExplorerPage.tsx`，提供最终成果的探索与分析界面。此任务是一个Epic，包含两个主要的子功能：一个使用MUI DataGrid实现的、支持分页和搜索的事件数据表格；一个使用 `react-force-graph` 实现的、支持节点交互的知识图谱可视化组件。",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          46,
          47,
          48
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 52,
        "title": "完成基于现有事件的知识图谱构建",
        "description": "基于已成功导入的2497条结构化事件，完成知识图谱构建的核心流程",
        "details": "1. 运行Cortex聚类工作流：python run_cortex_workflow.py 2. 运行关系分析：python run_relationship_analysis.py 3. 验证混合检索功能 4. 确保Web界面正常展示",
        "testStrategy": "",
        "status": "in-progress",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-07-16T12:53:46.081Z",
      "updated": "2025-08-15T14:45:55.205Z",
      "description": "Tasks for master context"
    }
  }
}